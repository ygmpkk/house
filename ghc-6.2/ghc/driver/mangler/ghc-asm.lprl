%************************************************************************
%*									*
\section[Driver-asm-fiddling]{Fiddling with assembler files}
%*									*
%************************************************************************

Tasks:
\begin{itemize}
\item
Utterly stomp out C functions' prologues and epilogues; i.e., the
stuff to do with the C stack.
\item
Any other required tidying up.
\end{itemize}

General note [chak]: Many regexps are very fragile because they rely on white
space being in the right place.  This caused trouble with gcc 2.95 (at least
on Linux), where the use of white space in .s files generated by gcc suddenly 
changed.  To guarantee compatibility across different versions of gcc, make
sure (at least on i386-.*-linux) that regexps tolerate varying amounts of white
space between an assembler statement and its arguments as well as after a the
comma separating multiple arguments.  

\emph{For the time being, I have corrected the regexps for i386-.*-linux.  I
didn't touch all the regexps for other i386 platforms, as I don't have
a box to test these changes.}

HPPA specific notes:
\begin{itemize}
\item
The HP linker is very picky about symbols being in the appropriate
space (code vs. data).  When we mangle the threaded code to put the
info tables just prior to the code, they wind up in code space
rather than data space.  This means that references to *_info from
un-mangled parts of the RTS (e.g. unthreaded GC code) get
unresolved symbols.  Solution:  mini-mangler for .c files on HP.  I
think this should really be triggered in the driver by a new -rts
option, so that user code doesn't get mangled inappropriately.
\item
With reversed tables, jumps are to the _info label rather than to
the _entry label.  The _info label is just an address in code
space, rather than an entry point with the descriptive blob we
talked about yesterday.  As a result, you can't use the call-style
JMP_ macro.  However, some JMP_ macros take _info labels as targets
and some take code entry points within the RTS.  The latter won't
work with the goto-style JMP_ macro.  Sigh.  Solution: Use the goto
style JMP_ macro, and mangle some more assembly, changing all
"RP'literal" and "LP'literal" references to "R'literal" and
"L'literal," so that you get the real address of the code, rather
than the descriptive blob.  Also change all ".word P%literal"
entries in info tables and vector tables to just ".word literal,"
for the same reason.  Advantage: No more ridiculous call sequences.
\end{itemize}

%************************************************************************
%*									*
\subsection{Top-level code}
%*									*
%************************************************************************

\begin{code}
$TargetPlatform = $TARGETPLATFORM;

($Pgm = $0) =~ s|.*/||;
$ifile = $ARGV[0];
$ofile = $ARGV[1];

if ( $TargetPlatform =~ /^i386-/ ) {
    if ($ARGV[2] eq '') {
	$StolenX86Regs = 4;
    } else {
        $StolenX86Regs = $ARGV[2];
    }
}

&mangle_asm($ifile,$ofile);

exit(0);
\end{code}

%************************************************************************
%*									*
\subsection{Constants for various architectures}
%*									*
%************************************************************************

\begin{code}
sub init_TARGET_STUFF {

    #--------------------------------------------------------#
    if ( $TargetPlatform =~ /^alpha-.*-.*/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\$L?C(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\$.*\.\.ng:|\.align\s+\d+|\.(globl|ent)\s+\S+|\#.*|\.(file|loc)\s+\S+\s+\S+|\.text|\.r?data)\n)';
    $T_COPY_DIRVS   = '^\s*(\$.*\.\.ng:|\#|\.(file|globl|ent|loc))';

    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';
    $T_DOT_WORD	    = '\.(long|quad|byte|word)';
    $T_DOT_GLOBAL   = '^\t\.globl';
    $T_HDR_literal  = "\.rdata\n\t\.align 3\n";
    $T_HDR_misc	    = "\.text\n\t\.align 3\n";
    $T_HDR_data	    = "\.data\n\t\.align 3\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 3\n";
    $T_HDR_srt      = "\.text\n\t\.align 3\n";
    $T_HDR_info	    = "\.text\n\t\.align 3\n";
    $T_HDR_entry    = "\.text\n\t\.align 3\n";
    $T_HDR_vector   = "\.text\n\t\.align 3\n";
    $T_HDR_direct   = "\.text\n\t\.align 3\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^hppa/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^L\$C(\d+)$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = '';

    $T_MOVE_DIRVS   = '^((\s+\.(IMPORT|EXPORT|PARAM).*|\s+\.align\s+\d+|\s+\.(SPACE|SUBSPA)\s+\S+|\s*)\n)';
    $T_COPY_DIRVS   = '^\s+\.(IMPORT|EXPORT)';

    $T_hsc_cc_PAT   = '\.STRING.*\)(hsc|cc) (.*)\\\\x09(.*)\\\\x00"';
    $T_DOT_WORD	    = '\.(blockz|word|half|byte)';
    $T_DOT_GLOBAL   = '^\s+\.EXPORT';
    $T_HDR_literal  = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$LIT\$\n";
    $T_HDR_misc	    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_data	    = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_consist  = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$LIT\$\n";
    $T_HDR_closure  = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_srt      = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_info	    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_entry    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_vector   = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_direct   = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^i386-.*-(linuxaout|freebsd2|nextstep3|cygwin32|mingw32)$/ ) {
				# NeXT added but not tested. CaS

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';
    $T_X86_PRE_LLBL_PAT = 'L';
    $T_X86_PRE_LLBL	    = 'L';
    $T_X86_BADJMP   = '^\tjmp [^L\*]';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s+\d+(,0x90)?|\.globl\s+\S+|\.text|\.data|\.stab[^n].*|\.type\s+.*|\.size\s+.*)\n)';
    $T_COPY_DIRVS   = '\.(globl|stab)';
    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';
    $T_DOT_WORD	    = '\.(long|word|value|byte|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.text\n\t\.align 2\n";
    $T_HDR_misc	    = "\.text\n\t\.align 2,0x90\n";
    $T_HDR_data	    = "\.data\n\t\.align 2\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 2\n";
    $T_HDR_srt      = "\.text\n\t\.align 2\n";
    $T_HDR_info	    = "\.text\n\t\.align 2\n"; # NB: requires padding
    $T_HDR_entry    = "\.text\n"; # no .align so we're right next to _info (arguably wrong...?)
    $T_HDR_vector   = "\.text\n\t\.align 2\n"; # NB: requires padding
    $T_HDR_direct   = "\.text\n\t\.align 2,0x90\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^i386-.*-(solaris2|linux|freebsd|netbsd|openbsd)$/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = # regexp that says what comes before APP/NO_APP
		      ($TargetPlatform =~ /-(linux|freebsd|netbsd)$/) ? '#' : '/' ;
    $T_CONST_LBL    = '^\.LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';
    $T_X86_PRE_LLBL_PAT = '\.L';
    $T_X86_PRE_LLBL	    = '.L';
    $T_X86_BADJMP   = '^\tjmp\s+[^\.\*]';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s+\d+(,\s*0x90)?|\.globl\s+\S+|\.text|\.data|\.section\s+.*|\.type\s+.*|\.size\s+\S+\s*,\s*\d+|\.ident.*|\.local.*)\n)';
    $T_COPY_DIRVS   = '^\s*\.(globl|type|size|local)';

    if ( $TargetPlatform =~ /freebsd|netbsd/ ) {
        $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';
    } else {
        $T_hsc_cc_PAT   = '\.string.*\)(hsc|cc) (.*)\\\\t(.*)"';
    }

    $T_DOT_WORD	    = '\.(long|value|word|byte|zero)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.section\t\.rodata\n"; # or just use .text??? (WDP 95/11)
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 4\n"; # ToDo: change align??
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n"; # ToDo: change align?
    $T_HDR_srt      = "\.text\n\t\.align 4\n"; # ToDo: change align?
    $T_HDR_info	    = "\.text\n\t\.align 4\n"; # NB: requires padding
    $T_HDR_entry    = "\.text\n"; # no .align so we're right next to _info (arguably wrong...?)
    $T_HDR_vector   = "\.text\n\t\.align 4\n"; # NB: requires padding
    $T_HDR_direct   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^ia64-.*-linux$/ ) {

    $T_STABBY       = 0; # 1 iff .stab things (usually if a.out format)
    $T_US           = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP      = '#';
    $T_CONST_LBL    = '^\.LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL     = ':';

    $T_MOVE_DIRVS   = '^(\s*\.(global|proc|pred\.safe_across_calls|text|data|section|subsection|align|size|type|ident)\s+.*\n)';
    $T_COPY_DIRVS   = '\.(global|proc)';

    $T_hsc_cc_PAT   = '\.string.*\)(hsc|cc) (.*)\\\\t(.*)"';
    $T_DOT_WORD     = '\.(long|value|byte|zero)';
    $T_DOT_GLOBAL   = '\.global';
    $T_HDR_literal  = "\.section\t\.rodata\n";
    $T_HDR_misc     = "\.text\n\t\.align 8\n";
    $T_HDR_data     = "\.data\n\t\.align 8\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 8\n";
    $T_HDR_srt      = "\.text\n\t\.align 8\n";
    $T_HDR_info     = "\.text\n\t\.align 8\n";
    $T_HDR_entry    = "\.text\n\t\.align 16\n";
    $T_HDR_vector   = "\.text\n\t\.align 8\n";
    $T_HDR_direct   = "\.text\n\t\.align 8\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^x86_64-.*-linux$/ ) {

    $T_STABBY       = 0; # 1 iff .stab things (usually if a.out format)
    $T_US           = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP      = '#';
    $T_CONST_LBL    = '^\.LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL     = ':';

    $T_MOVE_DIRVS   = '^(\s*\.(globl|text|data|section|align|size|type|ident|local)\s+.*\n)';
    $T_COPY_DIRVS   = '\.(globl|local)';

    $T_hsc_cc_PAT   = '\.string.*\)(hsc|cc) (.*)\\\\t(.*)"';
    $T_DOT_WORD     = '\.(quad|long|value|byte|zero)';
    $T_DOT_GLOBAL   = '\.global';
    $T_HDR_literal  = "\.section\t\.rodata\n";
    $T_HDR_misc     = "\.text\n\t\.align 8\n";
    $T_HDR_data     = "\.data\n\t\.align 8\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 8\n";
    $T_HDR_srt      = "\.text\n\t\.align 8\n";
    $T_HDR_info     = "\.text\n\t\.align 8\n";
    $T_HDR_entry    = "\.text\n\t\.align 8\n";
    $T_HDR_vector   = "\.text\n\t\.align 8\n";
    $T_HDR_direct   = "\.text\n\t\.align 8\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^m68k-.*-sunos4/ ) {

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^# MAY NOT APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align\s+\d+|\.proc\s+\d+|\.const|\.cstring|\.globl\s+\S+|\.text|\.data|\.even|\.stab[^n].*)\n)';
    $T_COPY_DIRVS   = '\.(globl|proc|stab)';
    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';

    $T_DOT_WORD	    = '\.long';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.text\n\t\.even\n";
    $T_HDR_misc	    = "\.text\n\t\.even\n";
    $T_HDR_data	    = "\.data\n\t\.even\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.even\n";
    $T_HDR_srt      = "\.text\n\t\.even\n";
    $T_HDR_info	    = "\.text\n\t\.even\n";
    $T_HDR_entry    = "\.text\n\t\.even\n";
    $T_HDR_vector   = "\.text\n\t\.even\n";
    $T_HDR_direct   = "\.text\n\t\.even\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^mips-.*/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^\s*#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\$LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align\s+\d+|\.(globl|ent)\s+\S+|\.text|\.r?data)\n)';
    $T_COPY_DIRVS   = '\.(globl|ent)';

    $T_hsc_cc_PAT   = 'I WAS TOO LAZY TO DO THIS BIT (WDP 95/05)';
    $T_DOT_WORD	    = '\.word';
    $T_DOT_GLOBAL   = '^\t\.globl';
    $T_HDR_literal  = "\t\.rdata\n\t\.align 2\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_consist  = 'TOO LAZY TO DO THIS TOO';
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_srt      = "\t\.text\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";
    $T_HDR_direct   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^powerpc-apple-.*/ ) {
				# Apple PowerPC Darwin/MacOS X.
    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DOESNT APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\LC\d+:'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align \d+|\.text|\.data|\.const_data|\.cstring|\.non_lazy_symbol_pointer|\.const|\.static_const|\.literal4|\.literal8|\.static_data|\.globl \S+|\.section .*|\.lcomm.*)\n)';
    $T_COPY_DIRVS   = '\.(globl|lcomm)';

    $T_hsc_cc_PAT   = '\.byte.*\)(hsc|cc) (.*)"\n\t\.byte \d+\n\t\.byte "(.*)"\n\t\.byte \d+';
    $T_DOT_WORD	    = '\.(long|short|byte|fill|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal  = "\t\.const_data\n\t\.align 2\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_consist  = "\t\.text\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.const_data\n\t\.align 2\n";
    $T_HDR_srt      = "\t\.text\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";
    $T_HDR_direct   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^powerpc-.*-linux/ ) {
				# PowerPC Linux
    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\.LC\d+:'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s+\d+(,\s*0x90)?|\.globl\s+\S+|\.text|\.data|\.section\s+.*|\.type\s+.*|\.size\s+\S+\s*,\s*\d+|\.ident.*|\.local.*)\n)';
    $T_COPY_DIRVS   = '^\s*\.(globl|type|size|local)';

    $T_hsc_cc_PAT   = '\.string.*\)(hsc|cc) (.*)\\\\t(.*)"';
    $T_DOT_WORD	    = '\.(long|short|byte|fill|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal  = "\t\.section\t.rodata\n\t\.align 2\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_consist  = "\t\.text\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_srt      = "\t\.text\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";
    $T_HDR_direct   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-(solaris2|openbsd)/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DOES NOT SEEM TO APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\.LLC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\.text|\.data|\.stab.*|\.section.*|\s+\.type.*|\s+\.size.*)\n)';
    $T_COPY_DIRVS   = '\.(global|proc|stab)';

    $T_hsc_cc_PAT   = '\.asciz.*\)(hsc|cc) (.*)\\\\t(.*)"';
    $T_DOT_WORD	    = '\.(long|word|byte|half|skip|uahalf|uaword)';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 8\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_srt      = "\.data\n\t\.align 4\n";
    $T_HDR_info	    = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";
    $T_HDR_direct   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-sunos4/ ) {

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^# DOES NOT SEEM TO APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\.text|\.data|\.stab.*)\n)';
    $T_COPY_DIRVS   = '\.(global|proc|stab)';
    $T_hsc_cc_PAT   = '\.ascii.*\)(hsc|cc) (.*)\\\\11"\n\t\.ascii\s+"(.*)\\\\0"';

    $T_DOT_WORD	    = '\.word';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 8\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_srt      = "\.data\n\t\.align 4\n";
    $T_HDR_info	    = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";
    $T_HDR_direct   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-linux/ ) {
    $T_STABBY       = 0; # 1 iff .stab things (usually if a.out format)
    $T_US           = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP      = '#'; # regexp that says what comes before APP/NO_APP
                           # Probably doesn't apply anyway
    $T_CONST_LBL    = '^\.LLC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL     = ':';

    $T_MOVE_DIRVS   = '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\.text|\.data|\.seg|\.stab.*|\.section.*|\s+\.type.*|\s+\.size.*)\n)';
    $T_COPY_DIRVS   = '\.(global|globl|proc|stab)';

    $T_hsc_cc_PAT   = '\.asciz.*\)(hsc|cc) (.*)\\\\t(.*)"';
    $T_DOT_WORD     = '\.(long|word|nword|xword|byte|half|short|skip|uahalf|uaword)';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc     = "\.text\n\t\.align 4\n";
    $T_HDR_data     = "\.data\n\t\.align 8\n";
    $T_HDR_consist  = "\.text\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_srt      = "\.data\n\t\.align 4\n";
    $T_HDR_info     = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";
    $T_HDR_direct   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } else {
	print STDERR "$Pgm: don't know how to mangle assembly language for: $TargetPlatform\n";
	exit 1;
    }

if ( 0 ) {
print STDERR "T_STABBY: $T_STABBY\n";
print STDERR "T_US: $T_US\n";
print STDERR "T_PRE_APP: $T_PRE_APP\n";
print STDERR "T_CONST_LBL: $T_CONST_LBL\n";
print STDERR "T_POST_LBL: $T_POST_LBL\n";
if ( $TargetPlatform =~ /^i386-/ ) {
    print STDERR "T_X86_PRE_LLBL_PAT: $T_X86_PRE_LLBL_PAT\n";
    print STDERR "T_X86_PRE_LLBL: $T_X86_PRE_LLBL\n";
    print STDERR "T_X86_BADJMP: $T_X86_BADJMP\n";
}
print STDERR "T_MOVE_DIRVS: $T_MOVE_DIRVS\n";
print STDERR "T_COPY_DIRVS: $T_COPY_DIRVS\n";
print STDERR "T_hsc_cc_PAT: $T_hsc_cc_PAT\n";
print STDERR "T_DOT_WORD: $T_DOT_WORD\n";
print STDERR "T_HDR_literal: $T_HDR_literal\n";
print STDERR "T_HDR_misc: $T_HDR_misc\n";
print STDERR "T_HDR_data: $T_HDR_data\n";
print STDERR "T_HDR_consist: $T_HDR_consist\n";
print STDERR "T_HDR_closure: $T_HDR_closure\n";
print STDERR "T_HDR_info: $T_HDR_info\n";
print STDERR "T_HDR_entry: $T_HDR_entry\n";
print STDERR "T_HDR_vector: $T_HDR_vector\n";
print STDERR "T_HDR_direct: $T_HDR_direct\n";
}

}
\end{code}

%************************************************************************
%*									*
\subsection{Mangle away}
%*									*
%************************************************************************

\begin{code}
sub mangle_asm {
    local($in_asmf, $out_asmf) = @_;

    # multi-line regexp matching:
    local($*) = 1;
    local($i, $c);


    &init_TARGET_STUFF();
    &init_FUNNY_THINGS();

    open(INASM, "< $in_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$in_asmf' (to read)\n");
    open(OUTASM,"> $out_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$out_asmf' (to write)\n");

    # read whole file, divide into "chunks":
    #	record some info about what we've found...

    @chk = ();		# contents of the chunk
    $numchks = 0;	# number of them
    @chkcat = ();	# what category of thing in each chunk
    @chksymb = ();	# what symbol(base) is defined in this chunk
    %entrychk = ();	# ditto, its entry code
    %closurechk = ();	# ditto, the (static) closure
    %srtchk = ();	# ditto, its SRT (for top-level things)
    %infochk = (); 	# given a symbol base, say what chunk its info tbl is in
    %vectorchk = ();    # ditto, return vector table
    $EXTERN_DECLS = '';	# .globl <foo> .text (MIPS only)

    $i = 0; $chkcat[0] = 'misc'; $chk[0] = '';

    while (<INASM>) {
	tr/\r//d if $TargetPlatform =~ /-mingw32$/; # In case Perl doesn't convert line endings
	next if $T_STABBY && /^\.stab.*${T_US}__stg_split_marker/o;
	next if $T_STABBY && /^\.stab.*ghc.*c_ID/;
	next if /^\t\.def.*endef$/;
	next if /${T_PRE_APP}(NO_)?APP/o; 
    	next if /^;/ && $TargetPlatform =~ /^hppa/;

	next if /(^$|^\t\.file\t|^ # )/ && $TargetPlatform =~ /^(mips|ia64)-/;

	if ( $TargetPlatform =~ /^mips-/ 
	  && /^\t\.(globl\S+\.text|comm\t)/ ) {
	    $EXTERN_DECLS .= $_ unless /(__DISCARD__|\b(PK_|ASSIGN_)(FLT|DBL)\b)/;
	# Treat .comm variables as data.  These show up in two (known) places:
	#
	#    - the module_registered variable used in the __stginit fragment.
	#      even though these are declared static and initialised, gcc 3.3
	#      likes to make them .comm, presumably to save space in the
	#      object file.
	#
	#    - global variables used to pass arguments from C to STG in
	#      a foreign export.  (is this still true? --SDM)
	# 
	} elsif ( /^\t\.comm.*$/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^\s+/ ) { # most common case first -- a simple line!
	    # duplicated from the bottom

	    $chk[$i] .= $_;

	} elsif ( /\.\.ng:$/ && $TargetPlatform =~ /^alpha-/ ) {
	    # Alphas: Local labels not to be confused with new chunks
	    $chk[$i] .= $_;
  
	# NB: all the rest start with a non-space

	} elsif ( $TargetPlatform =~ /^mips-/
	       && /^\d+:/ ) { # a funny-looking very-local label
	    $chk[$i] .= $_;

	} elsif ( /$T_CONST_LBL/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'literal';
	    $chksymb[$i] = $1;

	} elsif ( /^${T_US}__stg_split_marker(\d*)${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'splitmarker';
	    $chksymb[$i] = $1;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_info${T_POST_LBL}$/o ) {
	    $symb = $1;
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'infotbl';
	    $chksymb[$i] = $symb;

	    die "Info table already? $symb; $i\n" if defined($infochk{$symb});

	    $infochk{$symb} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_(entry|ret)${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'entry';
	    $chksymb[$i] = $1;

	    $entrychk{$1} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_closure${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'closure';
	    $chksymb[$i] = $1;

	    $closurechk{$1} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_srt${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'srt';
	    $chksymb[$i] = $1;

	    $srtchk{$1} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_ct${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^(${T_US}__gnu_compiled_c|gcc2_compiled\.)${T_POST_LBL}/o ) {
	    ; # toss it

	} elsif ( /^${T_US}[A-Za-z0-9_]+\.\d+${T_POST_LBL}$/o
	       || /^${T_US}.*_CAT${T_POST_LBL}$/o 		# PROF: _entryname_CAT
	       || /^${T_US}.*_done${T_POST_LBL}$/o		# PROF: _module_done
	       || /^${T_US}_module_registered${T_POST_LBL}$/o	# PROF: _module_registered
	       ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^([A-Za-z0-9_]+)\s+\.comm/ && $TargetPlatform =~ /^hppa/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'bss';
  	    $chksymb[$i] = '';

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_cc(s)?${T_POST_LBL}$/o ) {
            # all CC_ symbols go in the data section...
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_(alt|dflt)${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'misc';
	    $chksymb[$i] = '';
	} elsif ( /^${T_US}([A-Za-z0-9_]+)_vtbl${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'vector';
	    $chksymb[$i] = $1;

	    $vectorchk{$1} = $i;

	} elsif ( $TargetPlatform =~ /^i386-.*-solaris2/
	     &&   /^[A-Za-z0-9][A-Za-z0-9_]*:/ ) {
            # Some Solaris system headers contain function definitions (as
	    # opposed to mere prototypes), which end up in the .hc file when
	    # a Haskell module foreign imports the corresponding system 
	    # functions (most notably stat()).  We put them into the text 
            # segment.  Note that this currently does not extend to function
	    # names starting with an underscore. 
	    # - chak 7/2001
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'misc';
	    $chksymb[$i] = $1;

	} elsif ( /^${T_US}[A-Za-z0-9_]/o
		&& ( $TargetPlatform !~ /^hppa/ # need to avoid local labels in this case
		   || ! /^L\$\d+$/ ) ) {
	    local($thing);
	    chop($thing = $_);
	    $thing =~ s/:$//;
	    print STDERR "Warning: retaining unknown function \`$thing' in output from C compiler\n"
		unless # $KNOWN_FUNNY_THING{$thing}
		       /^${T_US}stg_.*${T_POST_LBL}$/o          # RTS internals
		    || /^${T_US}__stg_.*${T_POST_LBL}$/o        # more RTS internals
		    || /^${T_US}__fexp_.*${T_POST_LBL}$/o       # foreign export
		    || /^${T_US}.*_slow${T_POST_LBL}$/o         # slow entry
		    || /^${T_US}__stginit.*${T_POST_LBL}$/o     # __stginit<module>
		    || /^${T_US}.*_btm${T_POST_LBL}$/o          # large bitmaps
		    || /^${T_US}.*_srtd${T_POST_LBL}$/o          # large bitmaps
		    || /^${T_US}.*_fast${T_POST_LBL}$/o         # primops
		    || /^${T_US}.*_closure_tbl${T_POST_LBL}$/o  # closure tables
                    || /^_uname:/o;			        # x86/Solaris2
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'misc';
	    $chksymb[$i] = '';

	} elsif ( $TargetPlatform =~ /^powerpc-apple-.*/ && ( 
		   /^\.picsymbol_stub/
		|| /^\.section __TEXT,__picsymbol_stub1,.*/
		|| /^\.symbol_stub/
		|| /^\.section __TEXT,__symbol_stub1,.*/
		|| /^\.lazy_symbol_pointer/
		|| /^\.non_lazy_symbol_pointer/ ))
	{
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'dyld';
	    $chksymb[$i] = '';
	} elsif ( $TargetPlatform =~ /^powerpc-apple-.*/ && /^\.data/ && $chkcat[$i] eq 'dyld')
	{	# non_lazy_symbol_ptrs that point to local symbols
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'dyld';
	    $chksymb[$i] = '';
	} else { # simple line (duplicated at the top)

	    $chk[$i] .= $_;
	}
    }
    $numchks = $#chk + 1;

    # open CHUNKS, ">/tmp/chunks1" or die "Cannot open /tmp/chunks1: $!\n";
    # for (my $i = 0; $i < @chk; ++$i) { print CHUNKS "======= $i =======\n", $chk[$i] }
    # close CHUNKS;

    # the division into chunks is imperfect;
    # we throw some things over the fence into the next
    # chunk.
    #
    # also, there are things we would like to know
    # about the whole module before we start spitting
    # output.

    local($FIRST_MANGLABLE) = ($TargetPlatform =~ /^(alpha-|hppa|mips-)/) ? 1 : 0;
    local($FIRST_TOSSABLE ) = ($TargetPlatform =~ /^(hppa|mips-)/) ? 1 : 0;

#   print STDERR "first chunk to mangle: $FIRST_MANGLABLE\n";

    # Alphas: NB: we start meddling at chunk 1, not chunk 0
    # The first ".rdata" is quite magical; as of GCC 2.7.x, it
    # spits a ".quad 0" in after the very first ".rdata"; we
    # detect this special case (tossing the ".quad 0")!
    local($magic_rdata_seen) = 0;
  
    # HPPAs, MIPSen: also start medding at chunk 1

    for ($i = $FIRST_TOSSABLE; $i < $numchks; $i++) {
	$c = $chk[$i]; # convenience copy

#	print STDERR "\nCHK $i (BEFORE) (",$chkcat[$i],"):\n", $c;

	# toss all prologue stuff; HPPA is pretty weird
	# (see elsewhere)
	$c = &hppa_mash_prologue($c) if $TargetPlatform =~ /^hppa-/;

	# be slightly paranoid to make sure there's
	# nothing surprising in there
	if ( $c =~ /--- BEGIN ---/ ) {
	    if (($p, $r) = split(/--- BEGIN ---/, $c)) {

		# remove junk whitespace around the split point
		$p =~ s/\t+$//;
		$r =~ s/^\s*\n//;

		if ($TargetPlatform =~ /^i386-/) {
		    $p =~ s/^\tpushl\s+\%edi\n//;
		    $p =~ s/^\tpushl\s+\%esi\n//;
		    $p =~ s/^\tpushl\s+\%ebx\n//;
		    $p =~ s/^\tmovl\s+\%esi,\s*\d*\(\%esp\)\n//;
		    $p =~ s/^\tmovl\s+\%edi,\s*\d*\(\%esp\)\n//;
		    $p =~ s/^\tsubl\s+\$\d+,\s*\%esp\n//;
                    $p =~ s/^\tmovl\s+\$\d+,\s*\%eax\n\tcall\s+__alloca\n// if ($TargetPlatform =~ /^.*-cygwin32/);

		    # GCC 3.1 is in the habit of adding spurious writes to the
		    # stack in the prologue.  Just to be on the safe side,
		    # chuck these over the fence into the main code.
		    while ($p =~ /^\tmovl\s+\$\d+,\s*\d*\(\%esp\)\n/) {
			  # print "Spurious instruction: $&";
			  $p = $` . $';
			  $r = $& . $r;
		    }

		} elsif ($TargetPlatform =~ /^x86_64-/) {
		    $p =~ s/^\tpushq\s+\%r(bx|bp|12|13|14)\n//g;
		    $p =~ s/^\tmovq\s+\%r(bx|bp|12|13|14),\s*\d*\(\%rsp\)\n//g;
		    $p =~ s/^\tsubq\s+\$\d+,\s*\%rsp\n//;

		} elsif ($TargetPlatform =~ /^ia64-/) {
		    $p =~ s/^\t\.prologue .*\n//;
		    $p =~ s/^\t\.save ar\.pfs, r\d+\n\talloc r\d+ = ar\.pfs, 0, 3[12], \d+, 0\n//;
		    $p =~ s/^\t\.fframe \d+\n\tadds r12 = -\d+, r12\n//;
		    $p =~ s/^\t\.save rp, r\d+\n\tmov r\d+ = b0\n//;
		    $p =~ s/^\t\.(mii|mmi)\n//g;	# bundling is no longer sensible
		    $p =~ s/^\t;;\n//g;		# discard stops
		    $p =~ s/^\t\/\/.*\n//g;	# gcc inserts timings in // comments

		    # GCC 3.3 saves r1 in the prologue, move this to the body
		    if ($p =~ /^\tmov r\d+ = r1\n/) {
			  $p = $` . $';
			  $r = $& . $r;
		    }
		} elsif ($TargetPlatform =~ /^m68k-/) {
		    $p =~ s/^\tlink a6,#-?\d.*\n//;
 		    $p =~ s/^\tpea a6@\n\tmovel sp,a6\n//;    
 				# The above showed up in the asm code,
 				# so I added it here.
 				# I hope it's correct.
 				# CaS
		    $p =~ s/^\tmovel d2,sp\@-\n//;
		    $p =~ s/^\tmovel d5,sp\@-\n//; # SMmark.* only?
		    $p =~ s/^\tmoveml \#0x[0-9a-f]+,sp\@-\n//; # SMmark.* only?
		} elsif ($TargetPlatform =~ /^mips-/) {
		    # the .frame/.mask/.fmask that we use is the same
		    # as that produced by GCC for miniInterpret; this
		    # gives GDB some chance of figuring out what happened
		    $FRAME = "\t.frame\t\$sp,2168,\$31\n\t.mask\t0x90000000,-4\n\t.fmask\t0x00000000,0\n";
		    $p =~ s/^\t\.(frame).*\n/__FRAME__/g;
		    $p =~ s/^\t\.(mask|fmask).*\n//g;
		    $p =~ s/^\t\.cprestore.*\n/\t\.cprestore 416\n/; # 16 + 100 4-byte args
		    $p =~ s/^\tsubu\t\$sp,\$sp,\d+\n//;
		    $p =~ s/^\tsw\t\$31,\d+\(\$sp\)\n//;
		    $p =~ s/^\tsw\t\$fp,\d+\(\$sp\)\n//;
		    $p =~ s/^\tsw\t\$28,\d+\(\$sp\)\n//;
		    $p =~ s/__FRAME__/$FRAME/;
		} elsif ($TargetPlatform =~ /^powerpc-apple-.*/) {
		    $pcrel_label = $p;
		    $pcrel_label =~ s/(.|\n)*^(L\d+\$pb):\n(.|\n)*/$2/ or $pcrel_label = "";

		    $p =~ s/^\tmflr r0\n//;
 		    $p =~ s/^\tbl saveFP # f\d+\n//;
 		    $p =~ s/^\tbl saveFP ; save f\d+-f\d+\n//;
		    $p =~ s/^L\d+\$pb:\n//;
 		    $p =~ s/^\tstmw r\d+,-\d+\(r1\)\n//;
   		    $p =~ s/^\tstfd f\d+,-\d+\(r1\)\n//g;
 		    $p =~ s/^\tstw r0,\d+\(r1\)\n//g;
  		    $p =~ s/^\tstwu r1,-\d+\(r1\)\n//; 
  		    $p =~ s/^\tstw r\d+,-\d+\(r1\)\n//g; 
  		    $p =~ s/^\tbcl 20,31,L\d+\$pb\n//;
  		    $p =~ s/^L\d+\$pb:\n//;
  		    $p =~ s/^\tmflr r31\n//;

		    # This is bad: GCC 3 seems to zero-fill some local variables in the prologue
		    # under some circumstances, only when generating position dependent code.
		    # I have no idea why, and I don't think it is necessary, so let's toss it.
		    $p =~ s/^\tli r\d+,0\n//g;
		    $p =~ s/^\tstw r\d+,\d+\(r1\)\n//g;
		} elsif ($TargetPlatform =~ /^powerpc-.*-linux/) {
		    $p =~ s/^\tmflr 0\n//;
		    $p =~ s/^\tstmw \d+,\d+\(1\)\n//;
   		    $p =~ s/^\tstfd \d+,\d+\(1\)\n//g;
 		    $p =~ s/^\tstw r0,8\(1\)\n//;
  		    $p =~ s/^\tstwu 1,-\d+\(1\)\n//; 
  		    $p =~ s/^\tstw \d+,\d+\(1\)\n//g; 

		    # This is bad: GCC 3 seems to zero-fill some local variables in the prologue
		    # under some circumstances, only when generating position dependent code.
		    # I have no idea why, and I don't think it is necessary, so let's toss it.
		    $p =~ s/^\tli \d+,0\n//g;
		    $p =~ s/^\tstw \d+,\d+\(1\)\n//g;
		} else {
		    print STDERR "$Pgm: unknown prologue mangling? $TargetPlatform\n";
		}
		
		# HWL HACK: dont die, just print a warning
		#print stderr  "HWL: this should die! Prologue junk?: $p\n" if $p =~ /^\t[^\.]/;
		die "Prologue junk?: $p\n" if $p =~ /^\s+[^\s\.]/;
		
		if ($TargetPlatform =~ /^powerpc-apple-.*/ && $pcrel_label ne "") {
		    # on PowerPC, we have to keep a part of the prologue
		    # (which loads the current instruction pointer into register r31)
		    $p .= "bcl 20,31,$pcrel_label\n";
		    $p .= "$pcrel_label:\n";
		    $p .= "\tmflr r31\n";
		}
		
		# glue together what's left
		$c = $p . $r;
	    }
	}

	if ( $TargetPlatform =~ /^mips-/ ) {
	    # MIPS: first, this basic sequence may occur "--- END ---" or not
	    $c =~ s/^\tlw\t\$31,\d+\(\$sp\)\n\taddu\t\$sp,\$sp,\d+\n\tj\t\$31\n\t\.end/\t\.end/;
	}

	# toss all epilogue stuff; again, paranoidly
	if ( $c =~ /--- END ---/ ) {
	    if (($r, $e) = split(/--- END ---/, $c)) {
		if ($TargetPlatform =~ /^i386-/) {
		    $e =~ s/^\tret\n//;
		    $e =~ s/^\tpopl\s+\%edi\n//;
		    $e =~ s/^\tpopl\s+\%esi\n//;
		    $e =~ s/^\tpopl\s+\%edx\n//;
		    $e =~ s/^\tpopl\s+\%ecx\n//;
		    $e =~ s/^\taddl\s+\$\d+,\s*\%esp\n//;
		    $e =~ s/^\tsubl\s+\$-\d+,\s*\%esp\n//;
		} elsif ($TargetPlatform =~ /^ia64-/) {
		    $e =~ s/^\tmov ar\.pfs = r\d+\n//;
		    $e =~ s/^\tmov b0 = r\d+\n//;
		    $e =~ s/^\t\.restore sp\n\tadds r12 = \d+, r12\n//;
		    $e =~ s/^\tbr\.ret\.sptk\.many b0\n//;
		    $e =~ s/^\t\.(mii|mmi|mib)\n//g;	# bundling is no longer sensible
		    $e =~ s/^\t;;\n//g;			# discard stops - stop at end of body is sufficient
		    $e =~ s/^\t\/\/.*\n//g;		# gcc inserts timings in // comments
		} elsif ($TargetPlatform =~ /^m68k-/) {
		    $e =~ s/^\tunlk a6\n//;
		    $e =~ s/^\trts\n//;
		} elsif ($TargetPlatform =~ /^mips-/) {
		    $e =~ s/^\tlw\t\$31,\d+\(\$sp\)\n//;
		    $e =~ s/^\tlw\t\$fp,\d+\(\$sp\)\n//;
		    $e =~ s/^\taddu\t\$sp,\$sp,\d+\n//;
		    $e =~ s/^\tj\t\$31\n//;
 		} elsif ($TargetPlatform =~ /^powerpc-apple-.*/) {
  		    $e =~ s/^\taddi r1,r1,\d+\n//;
  		    $e =~ s/^\tcal r1,\d+\(r1\)\n//;
  		    $e =~ s/^\tlw?z? r\d+,\d+\(r1\)\n//; 
 		    $e =~ s/^\tmtlr r0\n//;
  		    $e =~ s/^\tblr\n//;
		} else {
		    print STDERR "$Pgm: unknown epilogue mangling? $TargetPlatform\n";
		}

		print STDERR "WARNING: Epilogue junk?: $e\n" if $e =~ /^\t\s*[^\.\s\n]/;

		# glue together what's left
		$c = $r . $e;
		$c =~ s/\n\t\n/\n/; # junk blank line
	    }
	}

	# On SPARCs, we don't do --- BEGIN/END ---, we just
	# toss the register-windowing save/restore/ret* instructions
	# directly:
	if ( $TargetPlatform =~ /^sparc-/ ) {
	    $c =~ s/^\t(save.*|restore.*|ret|retl)\n//g;
	    # throw away PROLOGUE comments
	    $c =~ s/^\t!#PROLOGUE# 0\n\t!#PROLOGUE# 1\n//;
	}

	# On Alphas, the prologue mangling is done a little later (below)

    	# toss all calls to __DISCARD__
	$c =~ s/^\t(call|jbsr|jal)\s+${T_US}__DISCARD__\n//go;
	$c =~ s/^\tjsr\s+\$26\s*,\s*${T_US}__DISCARD__\n//go if $TargetPlatform =~ /^alpha-/;
	$c =~ s/^\tbl\s+L___DISCARD__\$stub\n//go if $TargetPlatform =~ /^powerpc-apple-.*/;
	$c =~ s/^\tbl\s+__DISCARD__\n//go if $TargetPlatform =~ /^powerpc-.*-linux/;

	# IA64: mangle tailcalls into jumps here
	if ($TargetPlatform =~ /^ia64-/) {
	    while ($c =~ s/^\tbr\.call\.sptk\.many b0 = (.*)\n(?:^\.L([0-9]*):\n)?(?:\t;;\n)?(?:\tmov r1 = r\d+\n)?(?:\t;;\n)?\t--- TAILCALL ---\n(?:\t;;\n\tbr \.L\d+\n)?/\tbr\.few $1\n/) {
		# Eek, the gcc optimiser is getting smarter... if we see a jump to the --- TAILCALL ---
		# marker then we reapply the substitution at the source sites
		$c =~ s/^\tbr \.L$2\n/\t--- TAILCALL ---\n/g if ($2);
	    }
	}

	# MIPS: that may leave some gratuitous asm macros around
	# (no harm done; but we get rid of them to be tidier)
	$c =~ s/^\t\.set\tnoreorder\n\t\.set\tnomacro\n\taddu\t(\S+)\n\t\.set\tmacro\n\t\.set\treorder\n/\taddu\t$1\n/
	    if $TargetPlatform =~ /^mips-/;

    	# toss stack adjustment after DoSparks
    	$c =~ s/^(\tjbsr _DoSparks\n)\taddqw #8,sp/$1/g
		if $TargetPlatform =~ /^m68k-/; # this looks old...

	if ( $TargetPlatform =~ /^alpha-/ &&
	   ! $magic_rdata_seen &&
	   $c =~ /^\s*\.rdata\n\t\.quad 0\n\t\.align \d\n/ ) {
	    $c =~ s/^\s*\.rdata\n\t\.quad 0\n\t\.align (\d)\n/\.rdata\n\t\.align $1\n/;
	    $magic_rdata_seen = 1;
	}

	# pick some end-things and move them to the next chunk

	# pin a funny end-thing on (for easier matching):
	$c .= 'FUNNY#END#THING';

	while ( $c =~ /${T_MOVE_DIRVS}FUNNY#END#THING/o ) {

	    $to_move = $1;

	    # on x86 we try not to copy any directives into a literal
	    # chunk, rather we keep looking for the next real chunk.  This
	    # is because we get things like
	    #
	    #    .globl blah_closure
	    #    .LC32
	    #    	.string "..."
	    #    blah_closure:
	    #		...
            #
	    if ( $TargetPlatform =~ /^(i386|sparc|powerpc)/ && $to_move =~ /${T_COPY_DIRVS}/ ) {
		$j = $i + 1;
		while ( $j < $numchks  && $chk[$j] =~ /$T_CONST_LBL/) {
			$j++;
		}
		if ( $j < $numchks ) {
			$chk[$j] = $to_move . $chk[$j];
	        }
	    }

	    elsif ( $i < ($numchks - 1)
	      && ( $to_move =~ /${T_COPY_DIRVS}/
	        || ($TargetPlatform =~ /^hppa/ && $to_move =~ /align/ && $chkcat[$i+1] eq 'literal') )) {
		$chk[$i + 1] = $to_move . $chk[$i + 1];
		# otherwise they're tossed
	    }

	    $c =~ s/${T_MOVE_DIRVS}FUNNY#END#THING/FUNNY#END#THING/o;
	}

    	if ( $TargetPlatform =~ /^alpha-/ && $c =~ /^\t\.ent\s+(\S+)/ ) {
    	    $ent = $1;
	    # toss all prologue stuff, except for loading gp, and the ..ng address
	    unless ($c =~ /\.ent.*\n\$.*\.\.ng:/) {
		if (($p, $r) = split(/^\t\.prologue/, $c)) {
		    if (($keep, $junk) = split(/\.\.ng:/, $p)) {
			$keep =~ s/^\t\.frame.*\n/\t.frame \$30,0,\$26,0\n/;
			$keep =~ s/^\t\.(mask|fmask).*\n//g;
			$c = $keep . "..ng:\n";
		    } else {
			print STDERR "malformed code block ($ent)?\n"
		    }
		}
		$c .= "\t.prologue" . $r;
	    }
    	}
  
	$c =~ s/FUNNY#END#THING//;

#	print STDERR "\nCHK $i (AFTER) (",$chkcat[$i],"):\n", $c;

	$chk[$i] = $c; # update w/ convenience copy
    }

    # open CHUNKS, ">/tmp/chunks2" or die "Cannot open /tmp/chunks2: $!\n";
    # for (my $i = 0; $i < @chk; ++$i) { print CHUNKS "======= $i =======\n", $chk[$i] }
    # close CHUNKS;

    if ( $TargetPlatform =~ /^alpha-/ ) {
	# print out the header stuff first
	$chk[0] =~ s/^(\t\.file.*)"(ghc\d+\.c)"/$1"$ifile_root.hc"/;
	print OUTASM $chk[0];

    } elsif ( $TargetPlatform =~ /^hppa/ ) {
	print OUTASM $chk[0];

    } elsif ( $TargetPlatform =~ /^mips-/ ) {
	$chk[0] = "\t\.file\t1 \"$ifile_root.hc\"\n" . $chk[0];

	# get rid of horrible "<dollar>Revision: .*$" strings
	local(@lines0) = split(/\n/, $chk[0]);
	local($z) = 0;
	while ( $z <= $#lines0 ) {
	    if ( $lines0[$z] =~ /^\t\.byte\t0x24,0x52,0x65,0x76,0x69,0x73,0x69,0x6f$/ ) {
		undef($lines0[$z]);
		$z++;
		while ( $z <= $#lines0 ) {
		    undef($lines0[$z]);
		    last if $lines0[$z] =~ /[,\t]0x0$/;
		    $z++;
		}
	    }
	    $z++;
	}
	$chk[0] = join("\n", @lines0);
	$chk[0] =~ s/\n\n+/\n/;
	print OUTASM $chk[0];
    }

    # print out all the literal strings next
    for ($i = 0; $i < $numchks; $i++) {
	if ( $chkcat[$i] eq 'literal' ) {
	    print OUTASM $T_HDR_literal, $chk[$i];
	    print OUTASM "; end literal\n" if $TargetPlatform =~ /^hppa/; # for the splitter

	    $chkcat[$i] = 'DONE ALREADY';
	}
    }

    # on the HPPA, print out all the bss next
    if ( $TargetPlatform =~ /^hppa/ ) {
	for ($i = 1; $i < $numchks; $i++) {
	    if ( $chkcat[$i] eq 'bss' ) {
		print OUTASM "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$BSS\$\n\t.align 4\n";
		print OUTASM $chk[$i];

		$chkcat[$i] = 'DONE ALREADY';
	    }
	}
    }

    for ($i = $FIRST_MANGLABLE; $i < $numchks; $i++) {
#	print STDERR "$i: cat $chkcat[$i], symb $chksymb[$i]\n";

	next if $chkcat[$i] eq 'DONE ALREADY';

	if ( $chkcat[$i] eq 'misc' ) {
	    if ($chk[$i] ne '') {
		print OUTASM $T_HDR_misc;
 		&print_doctored($chk[$i], 0);
	    }

	} elsif ( $chkcat[$i] eq 'toss' ) {
	    print STDERR "*** NB: TOSSING code for $chksymb[$i] !!! ***\n";

	} elsif ( $chkcat[$i] eq 'data' ) {
	    if ($chk[$i] ne '') {
		print OUTASM $T_HDR_data;
		print OUTASM $chk[$i];
	    }

	} elsif ( $chkcat[$i] eq 'consist' ) {
	    if ( $chk[$i] =~ /$T_hsc_cc_PAT/o ) {
		local($consist) = "$1.$2.$3";
		$consist =~ s/,/./g;
		$consist =~ s/\//./g;
		$consist =~ s/-/_/g;
		$consist =~ s/[^A-Za-z0-9_.]/ZZ/g; # ToDo: properly?
		#
		# Using a cygnus-2.7-96q4 gcc build on hppas, the 
		# consistency chunk for ghc_cc_ID often (but not always!)
		# gets lumped with a bunch of .IMPORT directives containing info on
		# the code or data space nature of external symbols. We can't
		# toss these, so once the consistency ID has been turned into
		# a representable symbol, we substitute it for the symbol
		# that the string was attached to in the first place (ghc_cc_ID.)
		# (The original string is also substituted away.)
		#
		# This change may affect the code output on other platforms in
		# adverse ways, hence we restrict this hack hppa targets only.
		#
		#    -- 2/98 SOF
		if ( $TargetPlatform =~ /^hppa/ )  {
			$chk[$i] =~ s/^${T_US}ghc.*c_ID$TPOSTLBL/$consist/o;
			$chk[$i] =~ s/\t$T_hsc_cc_PAT/$T_HDR_misc/o;
			$consist = $chk[$i]; #clumsily
                }
		print OUTASM $T_HDR_consist, "${consist}${T_POST_LBL}\n";

	    } elsif ( $TargetPlatform !~ /^(mips)-/ ) { # we just don't try in those case (ToDo)
		# on mips: consistency string is just a v
		# horrible bunch of .bytes,
		# which I am too lazy to sort out (WDP 95/05)

		print STDERR "Couldn't grok consistency: ", $chk[$i];
	    }

	} elsif ( $chkcat[$i] eq 'splitmarker' ) {
	    # we can just re-constitute this one...
	    # NB: we emit _three_ underscores no matter what,
	    # so ghc-split doesn't have to care.
	    print OUTASM "___stg_split_marker",$chksymb[$i],"${T_POST_LBL}\n";

	} elsif ( $chkcat[$i] eq 'closure'
	       || $chkcat[$i] eq 'srt'
	       || $chkcat[$i] eq 'infotbl'
	       || $chkcat[$i] eq 'entry') { # do them in that order
	    $symb = $chksymb[$i];

	    # CLOSURE
	    if ( defined($closurechk{$symb}) ) {
		print OUTASM $T_HDR_closure;
		print OUTASM $chk[$closurechk{$symb}];
		$chkcat[$closurechk{$symb}] = 'DONE ALREADY';
	    }

	    # SRT
	    if ( defined($srtchk{$symb}) ) {
		print OUTASM $T_HDR_srt;
		print OUTASM $chk[$srtchk{$symb}];
		$chkcat[$srtchk{$symb}] = 'DONE ALREADY';
	    }

	    # INFO TABLE
	    if ( defined($infochk{$symb}) ) {

		print OUTASM $T_HDR_info;
                print OUTASM &rev_tbl($symb, $chk[$infochk{$symb}], 1);
                
		# entry code will be put here!

		$chkcat[$infochk{$symb}] = 'DONE ALREADY';
	    }

	    # STD ENTRY POINT
	    if ( defined($entrychk{$symb}) ) {

		$c = $chk[$entrychk{$symb}];

		print OUTASM $T_HDR_entry;

		&print_doctored($c, 1); # NB: the 1!!!

		$chkcat[$entrychk{$symb}] = 'DONE ALREADY';
	    }
	    
	} elsif ( $chkcat[$i] eq 'vector'
	       || $chkcat[$i] eq 'direct' ) { # do them in that order
	    $symb = $chksymb[$i];

	    # VECTOR TABLE
	    if ( defined($vectorchk{$symb}) ) {
		print OUTASM $T_HDR_vector;
		print OUTASM &rev_tbl($symb, $chk[$vectorchk{$symb}], 0);

		# direct return code will be put here!
		$chkcat[$vectorchk{$symb}] = 'DONE ALREADY';

	    } elsif ( $TargetPlatform =~ /^alpha-/ ) {
		# Alphas: the commented nop is for the splitter, to ensure
		# that no module ends with a label as the very last
		# thing.  (The linker will adjust the label to point
		# to the first code word of the next module linked in,
		# even if alignment constraints cause the label to move!)

		print OUTASM "\t# nop\n";
	    }
	    
 	} elsif ( $chkcat[$i] eq 'toc' ) {
            # silly optimisation to print tocs, since they come in groups...
 	    print OUTASM $T_HDR_toc;
            local($j)	= $i;
            while ($chkcat[$j] eq 'toc')
              { if (   $chk[$j] !~ /\.tc UpdatePAP\[TC\]/ # not needed: always turned into a jump.
                   ) 
                {
                  print OUTASM $chk[$j];
                }
                $chkcat[$j] = 'DONE ALREADY';
                $j++;
 	    }
 	    
 	} elsif ( $TargetPlatform =~ /^powerpc-apple-.*/ && $chkcat[$i] eq 'dyld' ) {
	    # powerpc-apple: dynamic linker stubs
	    if($chk[$i] !~ /\.indirect_symbol ___DISCARD__/)
	    {	# print them out unchanged, but remove the stubs for __DISCARD__
		print OUTASM $chk[$i];
	    }
	} else {
	    &tidy_up_and_die(1,"$Pgm: unknown chkcat (ghc-asm: $TargetPlatform)\n$chkcat[$i]\n$chk[$i]\n");
	}
    }

    print OUTASM $EXTERN_DECLS if $TargetPlatform =~ /^mips-/;

    # finished
    close(OUTASM) || &tidy_up_and_die(1,"Failed writing to $out_asmf\n");
    close(INASM)  || &tidy_up_and_die(1,"Failed reading from $in_asmf\n");
}
\end{code}

\begin{code}
sub hppa_mash_prologue { # OK, epilogue, too
    local($_) = @_;

    # toss all prologue stuff
    s/^\s+\.ENTRY[^\0]*--- BEGIN ---/\t.ENTRY/;

    # Lie about our .CALLINFO
    s/^\s+\.CALLINFO.*$/\t.CALLINFO NO_CALLS,NO_UNWIND/;

    # Get rid of P'

    s/LP'/L'/g;
    s/RP'/R'/g;

    # toss all epilogue stuff
    s/^\s+--- END ---[^\0]*\.EXIT/\t.EXIT/;

    # Sorry; we moved the _info stuff to the code segment.
    s/_info,DATA/_info,CODE/g;

    return($_);
}
\end{code}

\begin{code}
sub print_doctored {
    local($_, $need_fallthru_patch) = @_;

    if ( $TargetPlatform !~ /^i386-/ 
      || ! /^\t[a-z]/  # no instructions in here, apparently
      || /^${T_US}__stginit_[A-Za-z0-9_]+${T_POST_LBL}/) {
	print OUTASM $_;
	return;
    }
    # OK, must do some x86 **HACKING**

    local($entry_patch)	= '';
    local($exit_patch)	= '';

    # gotta watch out for weird instructions that
    # invisibly smash various regs:
    #   rep*	%ecx used for counting
    #   scas*	%edi used for destination index
    #   cmps*	%e[sd]i used for indices
    #   loop*	%ecx used for counting
    #
    # SIGH.

    # We cater for:
    #  * use of STG reg [ nn(%ebx) ] where no machine reg avail
    #
    #  * GCC used an "STG reg" for its own purposes
    #
    #  * some secret uses of machine reg, requiring STG reg
    #    to be saved/restored

    # The most dangerous "GCC uses" of an "STG reg" are when
    # the reg holds the target of a jmp -- it's tricky to
    # insert the patch-up code before we get to the target!
    # So here we change the jmps:

    # --------------------------------------------------------
    # it can happen that we have jumps of the form...
    #   jmp *<something involving %esp>
    # or
    #   jmp <something involving another naughty register...>
    #
    # a reasonably-common case is:
    #
    #   movl $_blah,<bad-reg>
    #   jmp  *<bad-reg>
    #

    s/^\tmovl\s+\$${T_US}(.*),\s*(\%e[abcd]x)\n\tjmp\s+\*\2/\tjmp $T_US$1/g;

    if ($StolenX86Regs <= 2 ) { # YURGH! spurious uses of esi?
	s/^\tmovl\s+(.*),\s*\%esi\n\tjmp\s+\*%esi\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*(.*\(.*\%esi.*\))\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*\%esi\n/\tmovl \%esi,\%eax\n\tjmp \*\%eax\n/g;
	die "$Pgm: (mangler) still have jump involving \%esi!\n$_"
	    if /(jmp|call)\s+.*\%esi/;
    }
    if ($StolenX86Regs <= 3 ) { # spurious uses of edi?
	s/^\tmovl\s+(.*),\s*\%edi\n\tjmp\s+\*%edi\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*(.*\(.*\%edi.*\))\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*\%edi\n/\tmovl \%edi,\%eax\n\tjmp \*\%eax\n/g;
	die "$Pgm: (mangler) still have jump involving \%edi!\n$_"
	    if /(jmp|call)\s+.*\%edi/;
    }

    # OK, now we can decide what our patch-up code is going to
    # be:

    # Offsets into register table - you'd better update these magic
    # numbers should you change its contents!
    # local($OFFSET_R1)=0;  No offset for R1 in new RTS.
    local($OFFSET_Hp)=88;

	# Note funky ".=" stuff; we're *adding* to these _patch guys
    if ( $StolenX86Regs <= 2
	 && ( /[^0-9]\(\%ebx\)/ || /\%esi/ || /^\tcmps/ ) ) { # R1 (esi)
	$entry_patch .= "\tmovl \%esi,(\%ebx)\n";
	$exit_patch  .= "\tmovl (\%ebx),\%esi\n";

	# nothing for call_{entry,exit} because %esi is callee-save
    }
    if ( $StolenX86Regs <= 3
	 && ( /${OFFSET_Hp}\(\%ebx\)/ || /\%edi/ || /^\t(scas|cmps)/ ) ) { # Hp (edi)
	$entry_patch .= "\tmovl \%edi,${OFFSET_Hp}(\%ebx)\n";
	$exit_patch  .= "\tmovl ${OFFSET_Hp}(\%ebx),\%edi\n";

	# nothing for call_{entry,exit} because %edi is callee-save
    }

    # --------------------------------------------------------
    # next, here we go with non-%esp patching!
    #
    s/^(\t[a-z])/$entry_patch$1/; # before first instruction

# Before calling GC we must set up the exit condition before the call
# and entry condition when we come back

    # fix _all_ non-local jumps:

    s/^\tjmp\s+\*${T_X86_PRE_LLBL_PAT}/\tJMP___SL/go;
    s/^\tjmp\s+${T_X86_PRE_LLBL_PAT}/\tJMP___L/go;

    s/^(\tjmp\s+.*\n)/$exit_patch$1/g; # here's the fix...

    s/^\tJMP___SL/\tjmp \*${T_X86_PRE_LLBL}/go;
    s/^\tJMP___L/\tjmp ${T_X86_PRE_LLBL}/go;

    if ($StolenX86Regs == 2 ) {
	die "ARGH! Jump uses \%esi or \%edi with -monly-2-regs:\n$_" 
	    if /^\t(jmp|call)\s+.*\%e(si|di)/;
    } elsif ($StolenX86Regs == 3 ) {
	die "ARGH! Jump uses \%edi with -monly-3-regs:\n$_" 
	    if /^\t(jmp|call)\s+.*\%edi/;
    }

    # --------------------------------------------------------
    # that's it -- print it
    #
    #die "Funny jumps?\n$_" if /${T_X86_BADJMP}/o; # paranoia

    print OUTASM $_;

    if ( $need_fallthru_patch ) { # exit patch for end of slow entry code
	print OUTASM $exit_patch;
	# ToDo: make it not print if there is a "jmp" at the end
    }
}
\end{code}

\begin{code}
sub init_FUNNY_THINGS {
    %KNOWN_FUNNY_THING = (
	# example
	# "${T_US}stg_.*{T_POST_LBL}", 1,  
    );
}
\end{code}

The following table reversal is used for both info tables and return
vectors.  In both cases, we remove the first entry from the table,
reverse the table, put the label at the end, and paste some code
(that which is normally referred to by the first entry in the table)
right after the table itself.  (The code pasting is done elsewhere.)

\begin{code}
sub rev_tbl {
    local($symb, $tbl, $discard1) = @_;

    return ($tbl) if ($TargetPlatform =~ /^ia64-/);

    local($before) = '';
    local($label) = '';
    local(@imports) = (); # hppa only
    local(@words) = ();
    local($after) = '';
    local(@lines) = split(/\n/, $tbl);
    local($i, $j);

    # Deal with the header...
    for ($i = 0; $i <= $#lines && $lines[$i] !~ /^\t?${T_DOT_WORD}\s+/o; $i++) {
	$label .= $lines[$i] . "\n",
	    next if $lines[$i] =~ /^[A-Za-z0-9_]+_info${T_POST_LBL}$/o
		 || $lines[$i] =~ /${T_DOT_GLOBAL}/o
		 || $lines[$i] =~ /^${T_US}\S+_vtbl${T_POST_LBL}$/o;

	$before .= $lines[$i] . "\n"; # otherwise...
    }

    # Grab the table data...
    if ( $TargetPlatform !~ /^hppa/ ) {
	for ( ; $i <= $#lines && $lines[$i] =~ /^\t?${T_DOT_WORD}\s+/o; $i++) {
	    push(@words, $lines[$i]);
	}
    } else { # hppa weirdness
	for ( ; $i <= $#lines && $lines[$i] =~ /^\s+(${T_DOT_WORD}|\.IMPORT)/; $i++) {
	    if ($lines[$i] =~ /^\s+\.IMPORT/) {
		push(@imports, $lines[$i]);
	    } else {
		# We don't use HP's ``function pointers''
		# We just use labels in code space, like normal people
		$lines[$i] =~ s/P%//;
		push(@words, $lines[$i]);
	    }
	}
    }

    # Now throw away any initial zero word from the table.  This is a hack
    # that lets us reduce the size of info tables when the SRT field is not
    # needed: see comments StgFunInfoTable in InfoTables.h.
    #
    # The .zero business is for Linux/ELF.
    # The .skip business is for Sparc/Solaris/ELF.
    # The .blockz business is for HPPA.
#    if ($discard1) {
#	if ($words[0] =~ /^\t?(${T_DOT_WORD}\s+0|\.zero\s+4|\.skip\s+4|\.blockz\s+4)/) {
#		shift(@words);
#    	}
#    }

    for (; $i <= $#lines; $i++) {
	$after .= $lines[$i] . "\n";
    }

    # Alphas: If we have anonymous text (not part of a procedure), the
    # linker may complain about missing exception information.  Bleh.
    # To suppress this, we place a .ent/.end pair around the code.
    # At the same time, we have to be careful and not enclose any leading
    # .file/.loc directives.
    if ( $TargetPlatform =~ /^alpha-/ && $label =~ /^([A-Za-z0-9_]+):$/) {
        local ($ident) = $1;
        $before =~ s/^((\s*\.(file|loc)\s+[^\n]*\n)*)/$1\t.ent $ident\n/;
    	$after .= "\t.end $ident\n";
    }

    # Alphas: The heroic Simon Marlow found a bug in the Digital UNIX
    # assembler (!) wherein .quad constants inside .text sections are
    # first narrowed to 32 bits then sign-extended back to 64 bits.
    # This obviously screws up our 64-bit bitmaps, so we work around
    # the bug by replacing .quad with .align 3 + .long + .long [ccshan]
    if ( $TargetPlatform =~ /^alpha-/ ) {
	foreach (@words) {
	    if (/^\s*\.quad\s+([-+0-9].*\S)\s*$/ && length $1 >= 10) {
		local ($number) = $1;
		if ($number =~ /^([-+])?(0x?)?([0-9]+)$/) {
		    local ($sign, $base, $digits) = ($1, $2, $3);
		    $base = (10, 8, 16)[length $base];
		    local ($hi, $lo) = (0, 0);
		    foreach $i (split(//, $digits)) {
			$j = $lo * $base + $i;
			$lo = $j % 4294967296;
			$hi = $hi * $base + ($j - $lo) / 4294967296;
		    }
		    ($hi, $lo) = (4294967295 - $hi, 4294967296 - $lo)
			if $sign eq "-";
		    $_ = "\t.align 3\n\t.long $lo\n\t.long $hi\n";
		    # printf STDERR "TURNING %s into 0x %08x %08x\n", $number, $hi, $lo;
		} else {
		    print STDERR "Cannot handle \".quad $number\" in info table\n";
		    exit 1;
		}
	    }
	}
    }

    $tbl = $before
	 . (($TargetPlatform !~ /^hppa/) ? '' : join("\n", @imports) . "\n")
	 . join("\n", @words) . "\n"
	 . $label . $after;

#   print STDERR "before=$before\n";
#   print STDERR "label=$label\n";
#   print STDERR "words=",(reverse @words),"\n";
#   print STDERR "after=$after\n";

    $tbl;
}
\end{code}

The HP is a major nuisance.  The threaded code mangler moved info
tables from data space to code space, but unthreaded code in the RTS
still has references to info tables in data space.  Since the HP
linker is very precise about where symbols live, we need to patch the
references in the unthreaded RTS as well.

\begin{code}
sub mini_mangle_asm_hppa {
    local($in_asmf, $out_asmf) = @_;

    open(INASM, "< $in_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$in_asmf' (to read)\n");
    open(OUTASM,"> $out_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$out_asmf' (to write)\n");

    while (<INASM>) {
	s/_info,DATA/_info,CODE/;   # Move _info references to code space
	s/P%_PR/_PR/;
	print OUTASM;
    }

    # finished:
    close(OUTASM) || &tidy_up_and_die(1,"Failed writing to $out_asmf\n");
    close(INASM)  || &tidy_up_and_die(1,"Failed reading from $in_asmf\n");
}

\end{code}

\begin{code}
sub tidy_up_and_die {
    local($return_val, $msg) = @_;
    print STDERR $msg;
    exit (($return_val == 0) ? 0 : 1);
}
\end{code}
