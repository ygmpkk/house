/* Auto generated GreenCard 2 code for FFI */
#include <windows.h>
#include "errors.h"
#include "win32debug.h"
#include "finalizers.h"
#include "Win32File_stub_ffi.h"
UINT prim_gENERIC_NONE()
{ UINT res1;
  do {res1= 0 ;
      
      return((UINT)(res1));} while(0);
}
UINT prim_gENERIC_READ()
{ UINT res1;
  do {res1=GENERIC_READ;
      
      return((UINT)(res1));} while(0);
}
UINT prim_gENERIC_WRITE()
{ UINT res1;
  do {res1=GENERIC_WRITE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_gENERIC_EXECUTE()
{ UINT res1;
  do {res1=GENERIC_EXECUTE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_gENERIC_ALL()
{ UINT res1;
  do {res1=GENERIC_ALL;
      
      return((UINT)(res1));} while(0);
}
UINT prim_dELETE()
{ UINT res1;
  do {res1=DELETE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_rEAD_CONTROL()
{ UINT res1;
  do {res1=READ_CONTROL;
      
      return((UINT)(res1));} while(0);
}
UINT prim_wRITE_DAC()
{ UINT res1;
  do {res1=WRITE_DAC;
      
      return((UINT)(res1));} while(0);
}
UINT prim_wRITE_OWNER()
{ UINT res1;
  do {res1=WRITE_OWNER;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sYNCHRONIZE()
{ UINT res1;
  do {res1=SYNCHRONIZE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sTANDARD_RIGHTS_REQUIRED()
{ UINT res1;
  do {res1=STANDARD_RIGHTS_REQUIRED;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sTANDARD_RIGHTS_READ()
{ UINT res1;
  do {res1=STANDARD_RIGHTS_READ;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sTANDARD_RIGHTS_WRITE()
{ UINT res1;
  do {res1=STANDARD_RIGHTS_WRITE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sTANDARD_RIGHTS_EXECUTE()
{ UINT res1;
  do {res1=STANDARD_RIGHTS_EXECUTE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sTANDARD_RIGHTS_ALL()
{ UINT res1;
  do {res1=STANDARD_RIGHTS_ALL;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sPECIFIC_RIGHTS_ALL()
{ UINT res1;
  do {res1=SPECIFIC_RIGHTS_ALL;
      
      return((UINT)(res1));} while(0);
}
UINT prim_aCCESS_SYSTEM_SECURITY()
{ UINT res1;
  do {res1=ACCESS_SYSTEM_SECURITY;
      
      return((UINT)(res1));} while(0);
}
UINT prim_mAXIMUM_ALLOWED()
{ UINT res1;
  do {res1=MAXIMUM_ALLOWED;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_SHARE_NONE()
{ UINT res1;
  do {res1= 0 ;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_SHARE_READ()
{ UINT res1;
  do {res1=FILE_SHARE_READ;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_SHARE_WRITE()
{ UINT res1;
  do {res1=FILE_SHARE_WRITE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_cREATE_NEW()
{ UINT res1;
  do {res1=CREATE_NEW;
      
      return((UINT)(res1));} while(0);
}
UINT prim_cREATE_ALWAYS()
{ UINT res1;
  do {res1=CREATE_ALWAYS;
      
      return((UINT)(res1));} while(0);
}
UINT prim_oPEN_EXISTING()
{ UINT res1;
  do {res1=OPEN_EXISTING;
      
      return((UINT)(res1));} while(0);
}
UINT prim_oPEN_ALWAYS()
{ UINT res1;
  do {res1=OPEN_ALWAYS;
      
      return((UINT)(res1));} while(0);
}
UINT prim_tRUNCATE_EXISTING()
{ UINT res1;
  do {res1=TRUNCATE_EXISTING;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_READONLY()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_READONLY;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_HIDDEN()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_HIDDEN;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_SYSTEM()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_SYSTEM;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_DIRECTORY()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_DIRECTORY;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_ARCHIVE()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_ARCHIVE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_NORMAL()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_NORMAL;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_TEMPORARY()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_TEMPORARY;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_ATTRIBUTE_COMPRESSED()
{ UINT res1;
  do {res1=FILE_ATTRIBUTE_COMPRESSED;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_WRITE_THROUGH()
{ UINT res1;
  do {res1=FILE_FLAG_WRITE_THROUGH;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_OVERLAPPED()
{ UINT res1;
  do {res1=FILE_FLAG_OVERLAPPED;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_NO_BUFFERING()
{ UINT res1;
  do {res1=FILE_FLAG_NO_BUFFERING;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_RANDOM_ACCESS()
{ UINT res1;
  do {res1=FILE_FLAG_RANDOM_ACCESS;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_SEQUENTIAL_SCAN()
{ UINT res1;
  do {res1=FILE_FLAG_SEQUENTIAL_SCAN;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_DELETE_ON_CLOSE()
{ UINT res1;
  do {res1=FILE_FLAG_DELETE_ON_CLOSE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_BACKUP_SEMANTICS()
{ UINT res1;
  do {res1=FILE_FLAG_BACKUP_SEMANTICS;
      
      return((UINT)(res1));} while(0);
}
UINT prim_fILE_FLAG_POSIX_SEMANTICS()
{ UINT res1;
  do {res1=FILE_FLAG_POSIX_SEMANTICS;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_ANONYMOUS()
{ UINT res1;
  do {res1=SECURITY_ANONYMOUS;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_IDENTIFICATION()
{ UINT res1;
  do {res1=SECURITY_IDENTIFICATION;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_IMPERSONATION()
{ UINT res1;
  do {res1=SECURITY_IMPERSONATION;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_DELEGATION()
{ UINT res1;
  do {res1=SECURITY_DELEGATION;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_CONTEXT_TRACKING()
{ UINT res1;
  do {res1=SECURITY_CONTEXT_TRACKING;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_EFFECTIVE_ONLY()
{ UINT res1;
  do {res1=SECURITY_EFFECTIVE_ONLY;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_SQOS_PRESENT()
{ UINT res1;
  do {res1=SECURITY_SQOS_PRESENT;
      
      return((UINT)(res1));} while(0);
}
UINT prim_sECURITY_VALID_SQOS_FLAGS()
{ UINT res1;
  do {res1=SECURITY_VALID_SQOS_FLAGS;
      
      return((UINT)(res1));} while(0);
}
DWORD prim_mOVEFILE_REPLACE_EXISTING()
{ DWORD res1;
  do {res1=MOVEFILE_REPLACE_EXISTING;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_mOVEFILE_COPY_ALLOWED()
{ DWORD res1;
  do {res1=MOVEFILE_COPY_ALLOWED;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_mOVEFILE_DELAY_UNTIL_REBOOT()
{ DWORD res1;
  do {res1=MOVEFILE_DELAY_UNTIL_REBOOT;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_BEGIN()
{ DWORD res1;
  do {res1=FILE_BEGIN;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_CURRENT()
{ DWORD res1;
  do {res1=FILE_CURRENT;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_END()
{ DWORD res1;
  do {res1=FILE_END;
      
      return((DWORD)(res1));} while(0);
}
UINT prim_dRIVE_UNKNOWN()
{ UINT res1;
  do {res1=DRIVE_UNKNOWN;
      
      return((UINT)(res1));} while(0);
}
UINT prim_dRIVE_NO_ROOT_DIR()
{ UINT res1;
  do {res1=DRIVE_NO_ROOT_DIR;
      
      return((UINT)(res1));} while(0);
}
UINT prim_dRIVE_REMOVABLE()
{ UINT res1;
  do {res1=DRIVE_REMOVABLE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_dRIVE_FIXED()
{ UINT res1;
  do {res1=DRIVE_FIXED;
      
      return((UINT)(res1));} while(0);
}
UINT prim_dRIVE_REMOTE()
{ UINT res1;
  do {res1=DRIVE_REMOTE;
      
      return((UINT)(res1));} while(0);
}
UINT prim_dRIVE_CDROM()
{ UINT res1;
  do {res1=DRIVE_CDROM;
      
      return((UINT)(res1));} while(0);
}
UINT prim_dRIVE_RAMDISK()
{ UINT res1;
  do {res1=DRIVE_RAMDISK;
      
      return((UINT)(res1));} while(0);
}
DWORD prim_dDD_RAW_TARGET_PATH()
{ DWORD res1;
  do {res1=DDD_RAW_TARGET_PATH;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_dDD_REMOVE_DEFINITION()
{ DWORD res1;
  do {res1=DDD_REMOVE_DEFINITION;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_dDD_EXACT_MATCH_ON_REMOVE()
{ DWORD res1;
  do {res1=DDD_EXACT_MATCH_ON_REMOVE;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_sCS_32BIT_BINARY()
{ DWORD res1;
  do {res1=SCS_32BIT_BINARY;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_sCS_DOS_BINARY()
{ DWORD res1;
  do {res1=SCS_DOS_BINARY;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_sCS_WOW_BINARY()
{ DWORD res1;
  do {res1=SCS_WOW_BINARY;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_sCS_PIF_BINARY()
{ DWORD res1;
  do {res1=SCS_PIF_BINARY;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_sCS_POSIX_BINARY()
{ DWORD res1;
  do {res1=SCS_POSIX_BINARY;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_sCS_OS216_BINARY()
{ DWORD res1;
  do {res1=SCS_OS216_BINARY;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_NOTIFY_CHANGE_FILE_NAME()
{ DWORD res1;
  do {res1=FILE_NOTIFY_CHANGE_FILE_NAME;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_NOTIFY_CHANGE_DIR_NAME()
{ DWORD res1;
  do {res1=FILE_NOTIFY_CHANGE_DIR_NAME;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_NOTIFY_CHANGE_ATTRIBUTES()
{ DWORD res1;
  do {res1=FILE_NOTIFY_CHANGE_ATTRIBUTES;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_NOTIFY_CHANGE_SIZE()
{ DWORD res1;
  do {res1=FILE_NOTIFY_CHANGE_SIZE;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_NOTIFY_CHANGE_LAST_WRITE()
{ DWORD res1;
  do {res1=FILE_NOTIFY_CHANGE_LAST_WRITE;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_NOTIFY_CHANGE_SECURITY()
{ DWORD res1;
  do {res1=FILE_NOTIFY_CHANGE_SECURITY;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_TYPE_UNKNOWN()
{ DWORD res1;
  do {res1=FILE_TYPE_UNKNOWN;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_TYPE_DISK()
{ DWORD res1;
  do {res1=FILE_TYPE_DISK;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_TYPE_CHAR()
{ DWORD res1;
  do {res1=FILE_TYPE_CHAR;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_TYPE_PIPE()
{ DWORD res1;
  do {res1=FILE_TYPE_PIPE;
      
      return((DWORD)(res1));} while(0);
}
DWORD prim_fILE_TYPE_REMOTE()
{ DWORD res1;
  do {res1=FILE_TYPE_REMOTE;
      
      return((DWORD)(res1));} while(0);
}
void* prim_deleteFile(char * arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = DeleteFile(arg1);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("DeleteFile")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
int access_prim_deleteFile_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_deleteFile_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_copyFile(char * arg1,char * arg2,int arg3)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = CopyFile(arg1, arg2, arg3);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("CopyFile")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1); free(arg2);
      return(&gc_result);} while(0);
}
int access_prim_copyFile_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_copyFile_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_moveFile(char * arg1,char * arg2)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = MoveFile(arg1, arg2);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("MoveFile")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1); free(arg2);
      return(&gc_result);} while(0);
}
int access_prim_moveFile_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_moveFile_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_moveFileEx(char * arg1,char * arg2,DWORD arg3)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = MoveFileEx(arg1, arg2, arg3);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("MoveFileEx")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1); free(arg2);
      return(&gc_result);} while(0);
}
int access_prim_moveFileEx_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_moveFileEx_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_setCurrentDirectory(char * arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = SetCurrentDirectory(arg1);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("SetCurrentDirectory")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
int access_prim_setCurrentDirectory_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_setCurrentDirectory_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_createDirectory(char * arg1,void * arg2)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = CreateDirectory(arg1, arg2);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("CreateDirecotry")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
int access_prim_createDirectory_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_createDirectory_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_createDirectoryEx(char * arg1,char * arg2,void * arg3)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = CreateDirectoryEx(arg1, arg2, arg3);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("CreateDirectoryEx")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1); free(arg2);
      return(&gc_result);} while(0);
}
int access_prim_createDirectoryEx_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_createDirectoryEx_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_removeDirectory(char * arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = RemoveDirectory(arg1);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("RemoveDirecotry")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
int access_prim_removeDirectory_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_removeDirectory_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_getBinaryType(char * arg1)
{ static struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  DWORD res1;int gc_failed;
	     char* gc_failstring;
  do { BOOL success = GetBinaryType(arg1,&res1);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorString("GetBinaryType")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (DWORD)(res1);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
DWORD access_prim_getBinaryType_res1(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
int access_prim_getBinaryType_gc_failed(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_getBinaryType_gc_failstring(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_createFile(char * arg1,UINT arg2,UINT arg3,void * arg4,UINT arg5,UINT arg6,HANDLE arg7)
{ static struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  HANDLE res1;int gc_failed;
	      char* gc_failstring;
  do {res1 = CreateFile(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      if ((gc_failed = (  res1 == 0  ))) {gc_failstring =  ErrorWin("CreateFile")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (HANDLE)(res1);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
HANDLE access_prim_createFile_res1(void *ptr){ return(((struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
int access_prim_createFile_gc_failed(void *ptr){ return(((struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_createFile_gc_failstring(void *ptr){ return(((struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_closeHandle(HANDLE arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = CloseHandle(arg1);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("CloseHandle")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
int access_prim_closeHandle_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_closeHandle_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
DWORD prim_getFileType(HANDLE arg1)
{ DWORD res1;
  do {res1 = GetFileType(arg1);
      
      return((DWORD)(res1));} while(0);
}
void* prim_flushFileBuffers(HANDLE arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = FlushFileBuffers(arg1);
      if ((gc_failed = ( !success ))) {gc_failstring =  ErrorWin("FlushFileBuffers")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
int access_prim_flushFileBuffers_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_flushFileBuffers_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_setEndOfFile(HANDLE arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = SetEndOfFile(arg1);
      if ((gc_failed = ( !success ))) {gc_failstring =  ErrorWin("SetEndOfFile")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
int access_prim_setEndOfFile_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_setEndOfFile_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_setFileAttributes(char * arg1,UINT arg2)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = SetFileAttributes(arg1,arg2);
      if ((gc_failed = ( !success ))) {gc_failstring =  ErrorWin("SetFileAttributes")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
int access_prim_setFileAttributes_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_setFileAttributes_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_getFileAttributes(char * arg1)
{ static struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  UINT res1;int gc_failed;
	    char* gc_failstring;
  do { res1=GetFileAttributes(arg1);
      if ((gc_failed = ( res1 == 0xFFFFFFFF ))) {gc_failstring =  ErrorWin("GetFileAttributes")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (UINT)(res1);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
UINT access_prim_getFileAttributes_res1(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
int access_prim_getFileAttributes_gc_failed(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_getFileAttributes_gc_failstring(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_win32_ReadFile(HANDLE arg1,void * arg2,DWORD arg3,LPOVERLAPPED arg4)
{ static struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  DWORD res1;int gc_failed;
	     char* gc_failstring;
  do { BOOL success = ReadFile(arg1,arg2,arg3,&res1,arg4);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorString("ReadFile")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (DWORD)(res1);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
DWORD access_prim_win32_ReadFile_res1(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
int access_prim_win32_ReadFile_gc_failed(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_win32_ReadFile_gc_failstring(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_win32_WriteFile(HANDLE arg1,void * arg2,DWORD arg3,LPOVERLAPPED arg4)
{ static struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  DWORD res1;int gc_failed;
	     char* gc_failstring;
  do {  BOOL success = WriteFile(arg1,arg2,arg3,&res1,arg4);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorString("WriteFile")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (DWORD)(res1);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
DWORD access_prim_win32_WriteFile_res1(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
int access_prim_win32_WriteFile_gc_failed(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_win32_WriteFile_gc_failstring(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_findFirstChangeNotification(char * arg1,int arg2,DWORD arg3)
{ static struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  HANDLE res1;int gc_failed;
	      char* gc_failstring;
  do {res1 = FindFirstChangeNotification(arg1, arg2, arg3);
      if ((gc_failed = (  res1 == 0  ))) {gc_failstring =  ErrorString("FindFirstChangeNotification")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (HANDLE)(res1);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1);
      return(&gc_result);} while(0);
}
HANDLE access_prim_findFirstChangeNotification_res1(void *ptr){ return(((struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
int access_prim_findFirstChangeNotification_gc_failed(void *ptr){ return(((struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_findFirstChangeNotification_gc_failstring(void *ptr){ return(((struct {HsPtr res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_findNextChangeNotification(HANDLE arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = FindNextChangeNotification(arg1);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("FindNextChangeNotification")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
int access_prim_findNextChangeNotification_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_findNextChangeNotification_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_findCloseChangeNotification(HANDLE arg1)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = FindCloseChangeNotification(arg1);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("FindCloseChangeNotification")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
int access_prim_findCloseChangeNotification_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_findCloseChangeNotification_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_defineDosDevice(DWORD arg1,char * arg2,char * arg3)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = DefineDosDevice(arg1, arg2, arg3);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("DefineDosDevice")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg2); free(arg3);
      return(&gc_result);} while(0);
}
int access_prim_defineDosDevice_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_defineDosDevice_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
int prim_areFileApisANSI()
{ int res1;
  do {res1 = AreFileApisANSI();
      
      return((int)(res1));} while(0);
}
void prim_setFileApisToOEM()
{ do {SetFileApisToOEM();
      ;} while(0);
}
void prim_setFileApisToANSI()
{ do {SetFileApisToANSI();
      ;} while(0);
}
UINT prim_setHandleCount(UINT arg1)
{ UINT res1;
  do {res1 = SetHandleCount(arg1);
      
      return((UINT)(res1));} while(0);
}
void* prim_getLogicalDrives()
{ static struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  DWORD res1;int gc_failed;
	     char* gc_failstring;
  do {res1 = GetLogicalDrives();
      if ((gc_failed = (  res1 == 0  ))) {gc_failstring =  ErrorString("GetLogicalDrives")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (DWORD)(res1);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
      
      return(&gc_result);} while(0);
}
DWORD access_prim_getLogicalDrives_res1(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
int access_prim_getLogicalDrives_gc_failed(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_getLogicalDrives_gc_failstring(void *ptr){ return(((struct {HsWord32 res1;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_getDiskFreeSpace(char * s)
{ static struct {HsWord32 res1;HsWord32 res2;HsWord32 res3;HsWord32 res4;HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  DWORD res1; DWORD res2; DWORD res3; DWORD res4;int gc_failed;
						 char* gc_failstring;
  do { BOOL success = GetDiskFreeSpace(s,&res1,&res2,&res3,&res4);
      if ((gc_failed = (  !success ))) {gc_failstring =  ErrorWin("GetDiskFreeSpace")  ;}
      else {gc_failed = 0;}
      gc_result.res1 = (DWORD)(res1);
      gc_result.res2 = (DWORD)(res2);
      gc_result.res3 = (DWORD)(res3);
      gc_result.res4 = (DWORD)(res4);
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       if (s) { free(s); };
      return(&gc_result);} while(0);
}
DWORD access_prim_getDiskFreeSpace_res1(void *ptr){ return(((struct {HsWord32 res1;HsWord32 res2;HsWord32 res3;HsWord32 res4;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res1);}
DWORD access_prim_getDiskFreeSpace_res2(void *ptr){ return(((struct {HsWord32 res1;HsWord32 res2;HsWord32 res3;HsWord32 res4;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res2);}
DWORD access_prim_getDiskFreeSpace_res3(void *ptr){ return(((struct {HsWord32 res1;HsWord32 res2;HsWord32 res3;HsWord32 res4;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res3);}
DWORD access_prim_getDiskFreeSpace_res4(void *ptr){ return(((struct {HsWord32 res1;HsWord32 res2;HsWord32 res3;HsWord32 res4;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->res4);}
int access_prim_getDiskFreeSpace_gc_failed(void *ptr){ return(((struct {HsWord32 res1;HsWord32 res2;HsWord32 res3;HsWord32 res4;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_getDiskFreeSpace_gc_failstring(void *ptr){ return(((struct {HsWord32 res1;HsWord32 res2;HsWord32 res3;HsWord32 res4;HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
void* prim_setVolumeLabel(char * arg1,char * arg2)
{ static struct {HsInt gc_failed;HsPtr gc_failstring;} gc_result;
  int gc_failed;
  char* gc_failstring;
  do { BOOL success = SetVolumeLabel(arg1, arg2);
      if ((gc_failed = (  !success  ))) {gc_failstring =  ErrorWin("SetVolumeLabel")  ;}
      else {gc_failed = 0;}
      gc_result.gc_failed = gc_failed;
      gc_result.gc_failstring = gc_failstring;
       free(arg1); free(arg2);
      return(&gc_result);} while(0);
}
int access_prim_setVolumeLabel_gc_failed(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failed);}
void* access_prim_setVolumeLabel_gc_failstring(void *ptr){ return(((struct {HsInt gc_failed;HsPtr gc_failstring;}*) ptr)->gc_failstring);}
